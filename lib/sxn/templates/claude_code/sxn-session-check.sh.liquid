#!/usr/bin/env bash
# SXN Session Check Hook for Claude Code
# Generated by sxn init - {{ timestamp | date: "%Y-%m-%d" }}
#
# - HARD BLOCKS write operations in reference projects
# - ALLOWS read-only queries in reference projects (with warning)
# - Auto-switches sxn session when blocked

set -e

# ============================================================
# Configuration - Detect dynamically from sxn
# ============================================================

check_sxn_installed() {
  command -v sxn >/dev/null 2>&1
}

# Get sessions folder from sxn status (returns full path)
get_sessions_folder() {
  sxn status 2>/dev/null | grep "Sessions Folder:" | sed 's/Sessions Folder: //' | tr -d ' '
}

# Get project root (parent of sessions folder, contains .sxn/)
get_project_root() {
  local sessions_folder
  sessions_folder=$(get_sessions_folder)
  if [ -n "$sessions_folder" ]; then
    dirname "$sessions_folder"
  fi
}

extract_issue_id() {
  local text="$1"
  echo "$text" | grep -oE '[A-Z]+-[0-9]+' | head -1
}

get_current_session() {
  sxn current 2>/dev/null | grep "Name:" | sed 's/Name: //' | tr -d ' '
}

session_exists() {
  local session_name="$1"
  local sessions_folder
  sessions_folder=$(get_sessions_folder)
  [ -d "$sessions_folder/$session_name" ]
}

get_session_path() {
  local session_name="$1"
  local sessions_folder
  sessions_folder=$(get_sessions_folder)
  echo "$sessions_folder/$session_name"
}

# ============================================================
# Read-Only Detection
# ============================================================

is_read_only_prompt() {
  local prompt="$1"
  local prompt_lower
  prompt_lower=$(echo "$prompt" | tr '[:upper:]' '[:lower:]')

  # Write patterns (action verbs) - check these FIRST
  local write_patterns=(
    " fix " " add " " create " " update " " modify " " change "
    " implement " " refactor " " write " " edit " " delete "
    " remove " " move " " rename " " replace " " insert "
    " run " " execute " " build " " test " " deploy " " commit "
    " install " " setup " " configure " " migrate "
  )

  # Check for write patterns first (takes precedence)
  for pattern in "${write_patterns[@]}"; do
    if [[ " $prompt_lower " == *"$pattern"* ]]; then
      return 1  # NOT read-only
    fi
  done

  # Read-only patterns (questions and queries)
  local readonly_patterns=(
    "^what " "^where " "^how " "^why " "^which " "^who "
    "^can you explain" "^explain " "^describe " "^show me"
    "^list " "^find " "^search " "^look for" "^look at"
    "^analyze " "^review " "^check " "^understand"
    "^tell me" "^help me understand" "^what's " "^what is"
  )

  # Check for read-only patterns
  for pattern in "${readonly_patterns[@]}"; do
    if [[ "$prompt_lower" =~ $pattern ]]; then
      return 0  # IS read-only
    fi
  done

  # Default: assume write operation (safer)
  return 1
}

# ============================================================
# Reference Project Detection
# ============================================================

is_reference_project() {
  local path="$1"
  local project_root
  local sessions_folder
  project_root=$(get_project_root)
  sessions_folder=$(get_sessions_folder)

  # No sxn project detected - not a reference project
  [ -z "$project_root" ] && return 1

  # If in sessions folder, it's a session (ALLOWED)
  if [[ "$path" == "$sessions_folder"* ]]; then
    return 1
  fi

  # If .sxnrc exists, it's a session (ALLOWED)
  if [ -f "$path/.sxnrc" ]; then
    return 1
  fi

  # If under project root but not in sessions, it's a reference (BLOCKED)
  if [[ "$path" == "$project_root"* ]]; then
    return 0  # IS a reference project
  fi

  return 1
}

get_session_from_path() {
  local path="$1"
  local sessions_folder
  sessions_folder=$(get_sessions_folder)

  if [ -n "$sessions_folder" ] && [[ "$path" == "$sessions_folder/"* ]]; then
    echo "$path" | sed "s|$sessions_folder/||" | cut -d'/' -f1
  elif [ -f "$path/.sxnrc" ]; then
    grep "session_name:" "$path/.sxnrc" 2>/dev/null | sed 's/session_name: //' | tr -d "' "
  fi
}

escape_json() {
  local text="$1"
  text="${text//\\/\\\\}"
  text="${text//\"/\\\"}"
  text="${text//$'\n'/\\n}"
  echo "$text"
}

output_allow() {
  local context="$1"
  if [ -z "$context" ]; then
    echo '{"decision": "allow"}'
  else
    local escaped
    escaped=$(escape_json "$context")
    echo "{\"decision\": \"allow\", \"additionalContext\": \"$escaped\"}"
  fi
}

output_block() {
  local reason="$1"
  local escaped
  escaped=$(escape_json "$reason")
  echo "{\"decision\": \"block\", \"reason\": \"$escaped\"}"
}

# ============================================================
# Main Logic
# ============================================================

main() {
  local input
  input=$(cat)
  local prompt="" cwd=""

  if command -v jq >/dev/null 2>&1; then
    prompt=$(echo "$input" | jq -r '.prompt // ""' 2>/dev/null || echo "")
    cwd=$(echo "$input" | jq -r '.cwd // ""' 2>/dev/null || echo "")
  fi

  [ -z "$cwd" ] && cwd=$(pwd)

  # ========================================
  # CHECK 1: Is sxn installed?
  # ========================================
  if ! check_sxn_installed; then
    # sxn not installed - allow (hook doesn't apply)
    output_allow ""
    exit 0
  fi

  # ========================================
  # CHECK 2: Is this an sxn-managed project?
  # ========================================
  local project_root
  project_root=$(get_project_root)
  if [ -z "$project_root" ]; then
    # Not in an sxn project - allow
    output_allow ""
    exit 0
  fi

  # ========================================
  # CHECK 3: In reference project?
  # ========================================
  if is_reference_project "$cwd"; then
    local current_session
    local issue_id
    local suggested_session=""
    current_session=$(get_current_session)
    issue_id=$(extract_issue_id "$prompt")

    # Determine which session to use
    if [ -n "$issue_id" ]; then
      suggested_session="$issue_id"
    elif [ -n "$current_session" ]; then
      suggested_session="$current_session"
    fi

    # ========================================
    # CHECK 3a: Is this a READ-ONLY prompt?
    # ========================================
    if is_read_only_prompt "$prompt"; then
      # Allow read-only with warning
      output_allow "WARNING: You are in a reference project directory ($cwd).

This is allowed for read-only queries, but any file modifications MUST be done in a session directory.

Current session: ${current_session:-'none'}
To switch to session: cd \$(sxn enter)"
      exit 0
    fi

    # ========================================
    # WRITE operation - HARD BLOCK
    # ========================================
    if [ -n "$suggested_session" ]; then
      local session_path
      session_path=$(get_session_path "$suggested_session")

      # Auto-create session if needed
      if [ -n "$issue_id" ] && ! session_exists "$issue_id"; then
        sxn add "$issue_id" >/dev/null 2>&1 || true
      fi

      # Auto-switch sxn to session
      sxn use "$suggested_session" >/dev/null 2>&1 || true

      output_block "REFERENCE PROJECT BLOCKED

You are in a reference project directory:
  $cwd

Write operations are NOT allowed here. All modifications must be in session directories.

ACTION REQUIRED:
  cd $session_path

Session '$suggested_session' is now active. Navigate to it and retry."
    else
      output_block "REFERENCE PROJECT BLOCKED

You are in a reference project directory:
  $cwd

Write operations are NOT allowed here.

ACTION REQUIRED:
1. Create a session:    sxn add <ISSUE-ID>
2. Navigate to it:      cd \$(sxn enter)

Or include a Linear issue ID (e.g., GRAIN-123) in your prompt."
    fi
    exit 0
  fi

  # ========================================
  # In session - check for issue ID mismatch
  # ========================================
  local current_session_from_path
  local issue_id
  current_session_from_path=$(get_session_from_path "$cwd")
  issue_id=$(extract_issue_id "$prompt")

  if [ -n "$issue_id" ] && [ -n "$current_session_from_path" ] && [ "$issue_id" != "$current_session_from_path" ]; then
    # User mentioned different issue - auto-switch
    if ! session_exists "$issue_id"; then
      sxn add "$issue_id" >/dev/null 2>&1 || true
    fi
    sxn use "$issue_id" >/dev/null 2>&1 || true

    local target_path
    target_path=$(get_session_path "$issue_id")

    output_allow "SESSION SWITCH: Detected $issue_id in prompt (was in $current_session_from_path).

Switched sxn to session $issue_id.
For file operations, use: $target_path"
    exit 0
  fi

  # Already in correct session - allow silently
  output_allow ""
  exit 0
}

main
