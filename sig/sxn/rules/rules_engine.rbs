# TypeScript RBS for Sxn::Rules::RulesEngine

module Sxn
  module Rules
    class RulesEngine
      # Execution result for rule application
      class ExecutionResult
        @applied_rules: Array[BaseRule]
        @failed_rules: Array[BaseRule]
        @skipped_rules: Array[Hash[Symbol, untyped]]
        @total_duration: Float
        @errors: Array[Hash[Symbol, untyped]]
        @start_time: Time?
        @end_time: Time?

        attr_reader applied_rules: Array[BaseRule]
        attr_reader failed_rules: Array[BaseRule]
        attr_reader total_duration: Float
        attr_reader errors: Array[Hash[Symbol, untyped]]

        def skipped_rules: () -> Array[BaseRule]

        def initialize: () -> void
        def start!: () -> void
        def finish!: () -> void
        def add_applied_rule: (BaseRule rule) -> void
        def add_failed_rule: (BaseRule rule, StandardError error) -> void
        def add_skipped_rule: (BaseRule rule, String reason) -> void
        def add_engine_error: (StandardError error) -> void
        def success?: () -> bool
        def total_rules: () -> Integer
        def to_h: () -> Hash[Symbol, untyped]
      end

      # Constants
      RULE_TYPES: Hash[String, untyped]

      # Instance variables
      @project_path: String
      @session_path: String
      @logger: untyped
      @applied_rules: Array[BaseRule]

      # Attributes
      attr_reader project_path: String
      attr_reader session_path: String
      attr_reader logger: untyped

      # Initialize the rules engine
      def initialize: (String project_path, String session_path, ?logger: untyped) -> void

      # Apply a set of rules with dependency resolution and parallel execution
      def apply_rules: (Hash[String, untyped] rules_config, ?Hash[Symbol, untyped] options) -> ExecutionResult

      # Rollback all applied rules in reverse order
      def rollback_rules: () -> bool

      # Validate rules configuration without executing
      def validate_rules_config: (Hash[String, untyped] rules_config) -> Array[BaseRule]

      # Strict validation that raises errors on any validation failure
      def validate_rules_strict: (Array[BaseRule] rules) -> void

      # Get available rule types
      def available_rule_types: () -> Array[String]

      private

      # Default execution options
      def default_options: () -> Hash[Symbol, untyped]

      # Validate that paths exist and are accessible
      def validate_paths!: () -> void

      # Load rules from configuration
      def load_rules: (Hash[String, untyped] rules_config) -> Array[BaseRule]

      # Load a single rule from specification
      def load_single_rule: (String rule_name, Hash[String, untyped] rule_spec) -> BaseRule

      # Create a rule instance
      def create_rule: (String rule_name, String rule_type, Hash[String, untyped] config, Array[String] dependencies, String session_path, String project_path) -> BaseRule

      # Get rule class for a given type
      def get_rule_class: (String rule_type) -> untyped

      # Validate all rules
      def validate_rules: (Array[BaseRule] rules) -> Array[BaseRule]

      # Validate that all dependencies exist
      def validate_dependencies: (Array[BaseRule] rules) -> void

      # Check for circular dependencies
      def check_circular_dependencies: (Array[BaseRule] rules) -> void

      # Detect circular dependencies using DFS
      def detect_circular_dependencies: (Array[BaseRule] rules) -> void

      # DFS helper for circular dependency detection
      def has_circular_dependency?: (BaseRule rule, Hash[String, BaseRule] rule_map, Set[String] visited, Set[String] rec_stack) -> bool

      # Resolve execution order based on dependencies (topological sort)
      def resolve_execution_order: (Array[BaseRule] rules) -> Array[Array[BaseRule]]

      # Execute a phase of rules (potentially in parallel)
      def execute_phase: (Array[BaseRule] phase_rules, Integer phase_index, ExecutionResult result, Hash[Symbol, untyped] options) -> void

      # Execute rules in a phase sequentially
      def execute_phase_sequential: (Array[BaseRule] phase_rules, ExecutionResult result, Hash[Symbol, untyped] options) -> void

      # Execute rules in a phase in parallel
      def execute_phase_parallel: (Array[BaseRule] phase_rules, ExecutionResult result, Hash[Symbol, untyped] options) -> void

      # Execute a single rule
      def execute_single_rule: (BaseRule rule, ExecutionResult result, Hash[Symbol, untyped] options, ?Mutex? mutex) -> void
    end
  end
end